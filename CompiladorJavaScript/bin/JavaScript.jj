/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
  CHOICE_AMBIGUITY_CHECK = 4;
  DEBUG_TOKEN_MANAGER=false;//DEBUGGEAR
}

PARSER_BEGIN(eg1)
import java.util.Vector;
import java.util.HashMap;
public class eg1
{
	static HashMap<String, TablaSimbolos> tablas = new HashMap <String, TablaSimbolos>();
	static TablaSimbolos tablageneral = new TablaSimbolos();
	static TablaSimbolos tablaactiva = tablageneral;
	
	static String nombrefuncion="HHHH";
	
  	public static void main(String args []) throws ParseException
  	{
  		tablas.put("general",tablageneral);
	    eg1 parser;// = new eg1(System.in);
          	if(args.length == 0){// ejecucion sin argumentos
        	System.out.println ("ExampleParser: Leyendo de la entrada estandar ...");
        	parser = new eg1(System.in);
      	}else if(args.length == 1){// ejecucion con fichero de entrada
	        System.out.println ("ExampleParser: Leyendo el fichero " + args[0]);
        	try {
          	parser = new eg1(new java.io.FileInputStream(args[0]));
        	}
        	catch(java.io.FileNotFoundException e) {
          	System.out.println ("ExampleParser: El fichero " + args[0] + " no ha sido encontrado.");
          	return;
        	}
      	}else {// en otro caso
        	System.out.println ("ExampleParser:  Debes utilizarlo de una de las siguientes formas:");
        	System.out.println ("         java ExampleParser < fichero");
        	System.out.println ("Or");
        	System.out.println ("         java ExampleParser fichero");
        	return;
      	}
    	//  String linea;
    	boolean cond = true;
    	while (cond)
    	{
      	if (args.length == 1)
      			System.out.println("Leyendo linea");
      	else
	      {
	      		System.out.println("Leyendo de teclado...");
	      		System.out.print("Enter an expression like \"1+(2+3)*4;\" :");
	     }
	      try
	      {
	        switch (eg1.one_line())
	        {
	          case -1 : 
	          System.out.println("Fin fichero"); // fin fichero
	          cond = false;
	          break;
	          case 0 : 
	          System.out.println("OK.");
	          break;
	          case 1 : 
	          System.out.println("OK. Funcion");
	          tablageneral.imprimir();
	          tablaactiva.imprimir();
	          break;
	          case 2 : 
	          System.out.println("Ok. Sentencia");
	          break;
	          case 3 : 
	          System.out.println("Ok. Expresion");
	          break;
	          case 4 : 
	          System.out.println("Ok. Asignacion");
	          break;
	          default : 
	          break;
	        }
	      }
	      catch (Exception e)
	      {
	        System.out.println("NOK.");
	        System.out.println(e.getMessage());
	        eg1.ReInit(System.in);
	      }
	      catch (Error e)
	      {
	        System.out.println("Oops.");
	        System.out.println(e.getMessage());
	        break;
	      }
	    }
	    System.out.println("Las tablas que hay son: "+tablas.toString());
	    if (tablas.containsKey("general"))	    {	    	TablaSimbolos nueva=tablas.get("general");
	    	nueva.imprimir();    	
	   }	    else	    	System.out.println("NO TIENES NI ZORRA");	 }
}

PARSER_END(eg1)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "/*": COMENTARIOS // mas de una linea de comentarios
|  "//": COMENTARIOS_UNA_LINEA
}

 // si aparece */ en COMENTARIOS se obvian y se vuelve al estado DEFAULT
< COMENTARIOS > SKIP : {
  "*/": DEFAULT
}
< COMENTARIOS > MORE : // probar en lugar de SKIP poner MORE
{
<  ~[] > // cualquier caracter que aparezca despues de /* no se tiene en cuenta
}

< COMENTARIOS_UNA_LINEA > SKIP : // comentarios de una linea
{
//  <( "\n" | "--" )> : DEFAULT
  "\n" : DEFAULT
}

< COMENTARIOS_UNA_LINEA > MORE : // probar en lugar de SKIP poner MORE
{
<  ~[] > // cualquier caracter que aparezca despues de // no se tiene en cuenta
}

TOKEN :
{
  < DO: "do" >
| < WHILE: "while" >
| < TRUE: "true" >
| < FALSE: "false" >
| < IF: "if" >
| < VAR: "var" >
| < RETURN: "return" >
| < NEW: "new" >
| < ARRAY: "Array" >
| < PROMPT: "prompt" >
| < DOCUMENT: "document" >
| < WRITE: "write" >
| < FUNCTION: "function" >
}

/* IDENTIFICADORES */

TOKEN :
{
  < IDENTIFICADOR: <LETRA> (<LETRA>|<DIGITO>|"_")* >
|
  < #LETRA:
      [ "a" - "z", "A" - "Z", "ñ", "Ñ" ] 
  >
|
  < #DIGITO: [ "0"-"9" ]
  >
}

/* CONSTANTES */

TOKEN :
{
  < INTEGER_LITERAL: (<DIGITO>)+ >  // el mayor entero puede ser XXXX
| < STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","0","\\","\'","\""] | ( ["\n","\r"] | "\r\n")))* "\""> 
}

/* SEPARADORES */

TOKEN :
{
  < PARENDRCHA: "(" >
| < PARENIZQ: ")" >
| < LLAVEDRCHA: "{" >
| < LLAVEIZQ: "}" >
| < CORCHETEDRCHA: "[" >
| < CORCHETEIZQ: "]" >
| < PUNTOYCOMA: ";" >
| < COMA: "," >
| < PUNTO: "." >
}

TOKEN :
{
  < ASIGNACION: "=" >
| < MAYOR: ">" >
| < MENOR: "<" >
| < MAS: "+" >
| < MENOS: "-" >
| < MUL: "*" >
| < DIV: "/" >
| < MODULO: "%" >
| < INTERROGANTE: "?" >
| < DOSPUNTOS: ":" >
| < IGUAL: "==" >
| < MENORIGUAL: "<=" >
| < MAYORIGUAL: ">=" >
| < DISTINTO: "!=" >
| < OR: "||" >
| < AND: "&&" >
| < INC: "++" >
| < DEC: "--" >

}


int one_line() : // punto de entrada del analizador sintactico
{}
{
		Funcion()	{
		return 1;	}
 	|   Sentencia()
 	{
 		return 2; 	}	
 	|		< EOF >
	{
  		return -1;
	}
}

void Funcion() : //Declaracion de funciones
{
  Token t;
  Token t2;
  Vector v = null;
  Symbol simbolo;
}
{
	(
		t="function" t2=<IDENTIFICADOR>  	  	{
  	  		nombrefuncion=t2.image;
  	  		simbolo = new Symbol(t2.image,t.beginLine);
  	  		tablageneral.insertarTS(t2.image,simbolo);  	  		//Necesito el nombre para guardarlo en la tabla de simbolos como clave
		}
  	  	"(" ( v=ParameterList() )? ")" CompoundStatement()
    	{
	    	if( v == null) {
	       		v = new Vector();
        	}
		}
  	)
}

// Returns a Vector of strings, one for each identifier.
Vector ParameterList() :
{
	Token t;
	Vector v = new Vector();
}
{
  t=<IDENTIFICADOR>
  	{
  	    System.out.println("tabla activa");
    	v.addElement(t.image);
    }
  ("," t=<IDENTIFICADOR>{
                            v.addElement(t.image);
                        })*
  						{
                         	return v;
                        }
}

void CompoundStatement() :
{
	Token t;
	JSVarDeclExpression vars;
	Vector<Token> v;
}
{
  //Con la entrada de un bloque, la operación set crea una nueva subtabla (dentro de la TS) ////////////////////////////////////////////
  //No hay funciones anidadas
  t="{"
	{//
//Entro en un bloque, luego creo una nueva subtabla como pone en los apuntes//  stmts = new JSCompoundStatement(t);
		tablaactiva = new TablaSimbolos(tablageneral);
		tablas.put(nombrefuncion, tablaactiva);//tablas es una lista de hash que guarda los nombres de tablas
	}
  	vars=Sentencia()
    {
  	}
  	"}"  	{
  		tablaactiva = tablas.get("general");  	}
  	/*El nacimiento de una nueva subtabla no implica
  	obligatoriamente una necesidad suplementaria de espacio en la tabla de símbolos,
   	pues los atributos de las nuevas variables se almacenan enla subtabla durante la
   	compilación del bloque y se borran después de que se lee el END delbloque.
	Esta operación también debe volver a activar la parte de la tabla de símbolos que contiene las variables presentes
	en elprograma antes de la entrada en el bloque */
}

JSVarDeclExpression Sentencia() :
{
  Token t;
  JSVarDeclExpression v=null;
  AsignInstruccion i=null;
}
{
	(
      LOOKAHEAD(2) < IDENTIFICADOR > "("  LlamadaFun() //Llamada a funcion
		{		}
	|
      LOOKAHEAD(2) PrimaryExpression() i=AssignmentExpression()
    	{
    	}
    |
      t=";"
   		{
        }
    |
      t="if" Condicion() Sentencia()
     	{
        }
    |
      t="do" Sentencia() "while" Condicion()
        {
        }
    |
      t="var" v=VariablesOrExpression()
      	{    	}	
    |
      t="return" Expresion()
        {
        }
    |
      t="prompt" Prompt()
        {      	}
    |
      < DOCUMENT > < PUNTO >< WRITE > "(" DocumentWrite()
  	)
  {  		return v;  }  
}

JSVarDeclExpression VariablesOrExpression() :
{
	Token t=null; //Los tokens que vaya leyendo los almacenaré aqui desde el lexico
	Vector v = null;   // Aqui me pasan las variables declaradas de la produccion siguiente del arbol
	JSVarDeclExpression e = null; //
	Symbol simbolo;
	JSExpresion expr=null;
	JSExpresion expr2=null;
}
{
	  LOOKAHEAD(3)expr=PrimaryExpression() < ASIGNACION > < NEW > < ARRAY > "(" expr2=PrimaryExpression() ")" //Expr2 tiene que ser constante numerica
      {
      		if(expr2._tipo!="ENTERO")      		{
      			System.out.println("Error");      		}
      		e=null;
      		System.out.println("Declaracion de array");
      }
      |		
      LOOKAHEAD(3)v=Variables()
	  {			int i=0;
			while(v.size() > i)			{//Introduce el tipo JSVarDecl
				Token tok= (Token)v.get(i);
				if (tablaactiva.existeClave(tok.image))				{
					System.out.println("La variable "+tok+" ya ha sido declarada");						}
				else				{
					simbolo = new Symbol(tok.image, tok.beginLine);					tablaactiva.insertarTS(tok.image, simbolo);
				}
				i++;				}
           	e = new JSVarDeclExpression(t, v);
       }
       {
       		return e;       }//    Expresion()
}

Vector<Token > Variables() :
{
	Vector v = new Vector<Token>();
  	Token t=null;
}
{
  t=Variable()
  	{
    	v.addElement(t);
       	//Inserto en la tabla activa el nombre de la variable que se ha declarado
        //tablaactiva.insertarTS();
    }
  ("," t=Variable()
  	{
    	v.addElement(t);
    }
  		)*
  {
  	return v;
  }
}

Token Variable() :
{
	Token t=null;
    //JSExpression e = null;
}
{
  (AssignmentExpression())?
 {
 	return t;
 }
}

JSDocumenWInstr DocumentWrite():
{	//Declaraciones
	JSDocumenWInstr doc=null;
	JSExpresion expr=null;
}{	expr=PrimaryExpression() ")" //Solo variable de tipo cadena
	{
			//Evalua la expresion y la muestra por pantalla
			doc=new JSDocumenWInstr(expr);
			return doc;				}
}

JSExpresion Condicion() :
{
  JSExpresion op=null;
}
{
  "(" Expresion() ")"
	{
			return op;
 	}
}

JSPrompt Prompt():
{
//Declaraciones
	Token t;
	JSPrompt promp=null;		}
{	Expresion()")"
	{
		promp = new JSPrompt();
		System.out.println("LLAMADA PROMPT");				}
	{			
	return promp;
}
}		
JSExpresion Expresion() :
{
	Token t;
	JSExpresion expr=null;
	AsignInstruccion asig1;
}
{
  asig1=AssignmentExpression()
  (t="," AssignmentExpression())*
  {  		return expr;
  }
}

AsignInstruccion AssignmentExpression() :
{
	Token t=null;
	InterrogInstruccion op=null;
	JSAritmetica rel=null;
	AsignInstruccion res=null;
	JSExpresion id=null;
	JSExpresion aux= null;
}
{
  	id = PrimaryExpression()
  	(LOOKAHEAD(2) < ASIGNACION >  rel=AdditiveExpression())*
  	//COMPROBAR EN SEMANTICO SI ES FUNCION...OPERACIO...ETC  	{
  			res=new AsignInstruccion(id, aux);
  			  	}
 	{
 		return res; 	}		
}

JSFuncion LlamadaFun():
{
	//Declaraciones
	JSFuncion fun=null;}
{
	ParameterList()")"	{
		System.out.println("Llamo a una funcion");
		return fun;	}		}

InterrogInstruccion ConditionalExpression():
{
	Token t;
	JSRelacional and;
	InterrogInstruccion op=null;
	AsignInstruccion asign1=null;
	AsignInstruccion asign2=null;
}
{//En lugar de AndExpression deberia de ser una condicion no?
//Falta hacer el resultado de AssignmentExpression()
  and= AndExpression()(t="?" asign1=AssignmentExpression() ":" asign2=AssignmentExpression())?
  {
  		op=new InterrogInstruccion(and,asign1,asign2);
  		return op;
  }
}
////////////////////////////////////////////////////////////////////////////////////////////
//Precedence is achieved using the cascading style,										  //
//where each production calls the higher-precedent production immediately following it.   //
//////////////////////////////////////////////////////////////////////////////////////////// 
JSRelacional AndExpression() :
{
	Token t=null;
	JSRelacional op=null;
	JSOperacion op1=null;
	JSOperacion op2=null;
}
{
  op1=RelationalExpression()
     (t="&&" op2=RelationalExpression())*
  {
  		op= new JSRelacional(t, op1, op2);  		return op;
  }
}

JSRelacional RelationalExpression() :
{
	Token t=null;
	JSRelacional op=null;
	JSAritmetica arit=null;
	JSExpresion expr1=null;
	JSExpresion expr2=null;
}
{
  arit=AdditiveExpression()
  (
  	( t="<" ) expr2=AdditiveExpression()
  	{
  		op=new JSRelacional(t, expr1, expr2); 
  	})*
  	{
  		Token aux = arit._t;
  		op=new JSRelacional(aux);//Modificar
		return op;
  	}
}

JSAritmetica AdditiveExpression() :
{
	Token t=null;
	JSAritmetica op=null;
	JSAritmetica op2=null;
	JSExpresion expr1=null;
	JSExpresion expr2=null;
}
{
	expr1=PrimaryExpression()
  	(
  		( t="+" ) expr2=PrimaryExpression()  		{  				
	  		op=new JSAritmetica(t, expr1, expr2, tablaactiva);
	  		op.reducir();
	  		return op;	  	})*
	{
		op2=new JSAritmetica(t,op,expr1,tablaactiva);
		op2.reducir();
  		return op2;  	}
}

JSExpresion PrimaryExpression() :
{
	JSExpresion cons =null;
  	Token t = null;
  	boolean islit = true;
}
{
  (
    "(" Expresion() ")"
    							{
                                	islit = false;
                                }
  |
    t=<IDENTIFICADOR>
    							{
                                	cons = new JSIdentificador(t, "ID", 4);
                                }
  |
    t=<INTEGER_LITERAL>
    							{
                                	cons = new JSNumero(t);
                                }
  |
    t=<STRING_LITERAL>
    							{
                               		cons = new JSCadena(t);
								}
  )
{	return cons;
}
}
